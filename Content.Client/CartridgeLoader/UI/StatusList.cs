using System.Collections;
using System.Numerics;
using JetBrains.Annotations;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Shared.Input;
using Robust.Shared.Timing;

namespace Content.Client.CartridgeLoader.UI;

public sealed class StatusList : Control, IList<StatusList.StatusItem>
{
    private bool _isAtBottom = true;

    /// The size of all the child widgets, in pixels
    private int _totalContentHeight;

    private VScrollBar _scrollBar;
    private readonly List<StatusItem> _itemList = new();
    public event Action<ItemListSelectedEventArgs>? OnItemSelected;
    public event Action<ItemListDeselectedEventArgs>? OnItemDeselected;
    public event Action<ItemListHoverEventArgs>? OnItemHover;

    public const string StylePropertyBackground = "itemlist-background";
    public const string StylePropertyItemBackground = "item-background";
    public const string StylePropertySelectedItemBackground = "selected-item-background";
    public const string StylePropertyDisabledItemBackground = "disabled-item-background";

    /// <summary>
    /// Gets or sets the ItemSeparation of individual list items
    /// </summary>
    public int ItemSeparation { get; set; } = 0; // Default value is 0px

    public int Count => _itemList.Count;
    public bool IsReadOnly => false;

    public bool ScrollFollowing { get; set; } = false;
    public int ButtonDeselectDelay { get; set; } = 100;

    public ItemListSelectMode SelectMode { get; set; } = ItemListSelectMode.Single;

    public StatusList()
    {
        MouseFilter = MouseFilterMode.Pass;

        RectClipContent = true;

        _scrollBar = new VScrollBar
        {
            Name = "_v_scroll",

            HorizontalAlignment = HAlignment.Right
        };
        AddChild(_scrollBar);
        _scrollBar.OnValueChanged += _ => _isAtBottom = _scrollBar.IsAtEnd;
    }

    private void RecalculateContentHeight()
    {
        _totalContentHeight = 0;
        foreach (var item in _itemList)
        {
            var itemHeight = 0f;
            if (item.Icon != null)
            {
                itemHeight = item.IconSize.Y;
            }

            itemHeight = Math.Max(itemHeight, ActualFont.GetHeight(UIScale));
            itemHeight += ActualItemBackground.MinimumSize.Y * UIScale;

            _totalContentHeight += (int)Math.Ceiling(itemHeight);
            _totalContentHeight += ItemSeparation;
        }

        //Remove unneeded ItemSeparation on last item.
        _totalContentHeight -= ItemSeparation;
        _scrollBar.MaxValue = Math.Max(_scrollBar.Page, _totalContentHeight);
        _updateScrollbarVisibility();
    }

    public void Add(StatusItem statusItem)
    {
        if (statusItem == null)
            return;
        if (statusItem.Owner != this)
            throw new ArgumentException("Item is owned by another ItemList!");

        _itemList.Add(statusItem);

        statusItem.OnSelected += Select;
        statusItem.OnDeselected += Deselect;

        RecalculateContentHeight();
        if (_isAtBottom && ScrollFollowing)
            _scrollBar.MoveToEnd();
    }

    public StatusItem AddItem(string text, Texture? icon = null, bool selectable = true, object? metadata = null)
    {
        var item = new StatusItem(this) { Text = text, Icon = icon, Selectable = selectable, Metadata = metadata };
        Add(item);
        return item;
    }

    public void Clear()
    {
        foreach (var item in _itemList.ToArray())
        {
            Remove(item);
        }

        _totalContentHeight = 0;
    }

    public bool Contains(StatusItem statusItem)
    {
        return _itemList.Contains(statusItem);
    }

    public void CopyTo(StatusItem[] array, int arrayIndex)
    {
        _itemList.CopyTo(array, arrayIndex);
    }

    public bool Remove(StatusItem statusItem)
    {
        if (statusItem == null)
            return false;

        var value = _itemList.Remove(statusItem);

        statusItem.OnSelected -= Select;
        statusItem.OnDeselected -= Deselect;

        RecalculateContentHeight();
        if (_isAtBottom && ScrollFollowing)
            _scrollBar.MoveToEnd();

        return value;
    }

    public void RemoveAt(int index)
    {
        Remove(this[index]);
    }

    public IEnumerator<StatusItem> GetEnumerator()
    {
        return _itemList.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    public int IndexOf(StatusItem statusItem)
    {
        return _itemList.IndexOf(statusItem);
    }

    public void Insert(int index, StatusItem statusItem)
    {
        if (statusItem == null)
            return;
        if (statusItem.Owner != this)
            throw new ArgumentException("Item is owned by another ItemList!");

        _itemList.Insert(index, statusItem);

        statusItem.OnSelected += Select;
        statusItem.OnDeselected += Deselect;

        RecalculateContentHeight();
        if (_isAtBottom && ScrollFollowing)
            _scrollBar.MoveToEnd();
    }

    // Without this attribute, this would compile into a property called "Item", causing problems with the Item class.
    [System.Runtime.CompilerServices.IndexerName("IndexItem")]
    public StatusItem this[int index]
    {
        get => _itemList[index];
        set => _itemList[index] = value;
    }

    public IEnumerable<StatusItem> GetSelected()
    {
        var list = new List<StatusItem>();

        for (var i = 0; i < _itemList.Count; i++)
        {
            var item = _itemList[i];
            if (item.Selected)
                list.Add(item);
        }

        return list;
    }

    private void Select(int idx)
    {
        if (SelectMode != ItemListSelectMode.Multiple)
            ClearSelected(idx);
        OnItemSelected?.Invoke(new ItemListSelectedEventArgs(idx, this));
    }

    private void Select(StatusItem statusItem)
    {
        var idx = IndexOf(statusItem);
        if (idx != -1)
            Select(idx);
    }

    private void Deselect(int idx)
    {
        OnItemDeselected?.Invoke(new ItemListDeselectedEventArgs(idx, this));
    }

    private void Deselect(StatusItem statusItem)
    {
        var idx = IndexOf(statusItem);
        if (idx == -1)
            return;
        Deselect(idx);
    }

    public void ClearSelected(int? except = null)
    {
        foreach (var item in GetSelected())
        {
            if (IndexOf(item) == except)
                continue;
            item.Selected = false;
        }
    }

    public void SortItemsByText() => Sort((p, q) => string.Compare(p.Text, q.Text, StringComparison.Ordinal));

    public void Sort(Comparison<StatusItem> comparison) => _itemList.Sort(comparison);


    public void EnsureCurrentIsVisible()
    {
        // TODO: Implement this.
    }

    public int GetItemAtPosition(Vector2 position, bool exact = false)
    {
        throw new NotImplementedException();
    }

    public Font ActualFont
    {
        get
        {
            if (TryGetStyleProperty<Font>("font", out var font))
            {
                return font;
            }

            return UserInterfaceManager.ThemeDefaults.DefaultFont;
        }
    }

    public Color ActualFontColor
    {
        get
        {
            if (TryGetStyleProperty("font-color", out Color fontColor))
            {
                return fontColor;
            }

            return Color.White;
        }
    }

    public StyleBox ActualBackground
    {
        get
        {
            if (TryGetStyleProperty<StyleBox>(StylePropertyBackground, out var bg))
            {
                return bg;
            }

            return new StyleBoxFlat();
        }
    }

    public StyleBox ActualItemBackground
    {
        get
        {
            if (TryGetStyleProperty<StyleBox>(StylePropertyItemBackground, out var bg))
            {
                return bg;
            }

            return new StyleBoxFlat();
        }
    }

    public StyleBox ActualSelectedItemBackground
    {
        get
        {
            if (TryGetStyleProperty<StyleBox>(StylePropertySelectedItemBackground, out var bg))
            {
                return bg;
            }

            return new StyleBoxFlat();
        }
    }

    public StyleBox ActualDisabledItemBackground
    {
        get
        {
            if (TryGetStyleProperty<StyleBox>(StylePropertyDisabledItemBackground, out var bg))
            {
                return bg;
            }

            return new StyleBoxFlat();
        }
    }

    public void ScrollToBottom()
    {
        _scrollBar.MoveToEnd();
        _isAtBottom = true;
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        base.Draw(handle);

        const int iconScale = 2;

        var sizeBox = PixelSizeBox;

        var font = ActualFont;
        var listBg = ActualBackground;
        var iconBg = ActualItemBackground;
        var iconSelectedBg = ActualSelectedItemBackground;
        var iconDisabledBg = ActualDisabledItemBackground;

        var offset = -_scrollBar.Value;

        listBg.Draw(handle, PixelSizeBox, UIScale);

        foreach (var item in _itemList)
        {
            var bg = iconBg;

            if (item.Disabled)
                bg = iconDisabledBg;

            if (item.Selected)
            {
                bg = iconSelectedBg;
            }

            var itemHeight = 0f;
            if (item.Icon != null)
            {
                itemHeight = item.IconSize.Y;
            }

            itemHeight = Math.Max(itemHeight, font.GetHeight(UIScale));
            itemHeight += ActualItemBackground.MinimumSize.Y * UIScale;

            var region = UIBox2.FromDimensions(0, offset, PixelWidth, itemHeight);
            item.Region = region;

            if (region.Intersects(sizeBox))
            {
                bg.Draw(handle, item.Region.Value, UIScale);

                var contentBox = bg.GetContentBox(item.Region.Value, UIScale);
                if (item.Icon != null)
                {
                    // Centering the icon: find the center Y coordinates of the item, and then raise the icon to half its height.
                    var drawOffset = contentBox.TopLeft + new Vector2(0, itemHeight / 2 - item.Icon!.Height * iconScale / 2f);

                    if (item.IconRegion.Size == Vector2.Zero)
                    {
                        handle.DrawTextureRect(item.Icon,
                            UIBox2.FromDimensions(drawOffset, item.IconSize * iconScale),
                            item.IconModulate);
                    }
                    else
                    {
                        handle.DrawTextureRectRegion(item.Icon,
                            UIBox2.FromDimensions(drawOffset, item.IconSize * iconScale),
                            item.IconRegion,
                            item.IconModulate);
                    }
                }

                if (item.Text != null)
                {
                    var textBox = new UIBox2(contentBox.Left + item.IconSize.X * iconScale,
                        contentBox.Top,
                        contentBox.Right,
                        contentBox.Bottom);
                    DrawTextInternal(handle, item.Text, textBox);
                }
            }

            offset += itemHeight;

            // Add a ItemSeparation at the bottom of each item.
            offset += ItemSeparation;
        }
    }

    protected void DrawTextInternal(DrawingHandleScreen handle, string text, UIBox2 box)
    {
        var font = ActualFont;

        var color = ActualFontColor;
        var offsetY = (int)(box.Height - font.GetHeight(UIScale)) / 2;
        var baseLine = new Vector2i(5, offsetY + font.GetAscent(UIScale)) + box.TopLeft;

        foreach (var rune in text.EnumerateRunes())
        {
            if (!font.TryGetCharMetrics(rune, UIScale, out var metrics))
            {
                continue;
            }

            if (!(baseLine.X < box.Left || baseLine.X + metrics.Advance > box.Right))
            {
                font.DrawChar(handle, rune, baseLine, UIScale, color);
            }

            baseLine += new Vector2(metrics.Advance, 0);
        }
    }

    protected override Vector2 MeasureOverride(Vector2 availableSize)
    {
        var size = Vector2.Zero;
        if (ActualBackground != null)
        {
            size += ActualBackground.MinimumSize;
        }

        return size;
    }

    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        base.KeyBindDown(args);

        if (SelectMode == ItemListSelectMode.None || args.Function != EngineKeyFunctions.UIClick)
        {
            return;
        }

        foreach (var item in _itemList)
        {
            if (item.Region == null)
                continue;

            if (!item.Region.Value.Contains(args.RelativePixelPosition))
                continue;

            if (item.Selectable && !item.Disabled)
            {
                if (item.Selected && SelectMode != ItemListSelectMode.Button)
                {
                    if (SelectMode != ItemListSelectMode.Multiple)
                        ClearSelected();
                    item.Selected = false;
                    return;
                }

                item.Selected = true;
                if (SelectMode == ItemListSelectMode.Button)
                    Timer.Spawn(ButtonDeselectDelay, () => { item.Selected = false; });
            }

            break;
        }
    }

    protected override void MouseMove(GUIMouseMoveEventArgs args)
    {
        base.MouseMove(args);

        for (var idx = 0; idx < _itemList.Count; idx++)
        {
            var item = _itemList[idx];
            if (item.Region == null)
                continue;
            if (!item.Region.Value.Contains(args.RelativePosition))
                continue;
            OnItemHover?.Invoke(new ItemListHoverEventArgs(idx, this));
            break;
        }
    }

    protected override void MouseWheel(GUIMouseWheelEventArgs args)
    {
        base.MouseWheel(args);

        if (MathHelper.CloseToPercent(0, args.Delta.Y))
        {
            return;
        }

        _scrollBar.ValueTarget -= _getScrollSpeed() * args.Delta.Y;
        _isAtBottom = _scrollBar.IsAtEnd;

        args.Handle();
    }

    [Pure]
    private int _getScrollSpeed()
    {
        var font = ActualFont;
        return font.GetHeight(UIScale) * 2;
    }

    protected override void Resized()
    {
        base.Resized();

        var styleBoxSize = (ActualBackground?.MinimumSize.Y ?? 0) * UIScale;
        _scrollBar.Page = PixelSize.Y - styleBoxSize;
        RecalculateContentHeight();
    }

    protected override void UIScaleChanged()
    {
        RecalculateContentHeight();

        base.UIScaleChanged();
    }

    private void _updateScrollbarVisibility()
    {
        _scrollBar.Visible = _totalContentHeight + ActualBackground.MinimumSize.Y > Height;
    }

    public abstract class ItemListEventArgs : EventArgs
    {
        /// <summary>
        ///     The ItemList this event originated from.
        /// </summary>
        public StatusList ItemList { get; }

        protected ItemListEventArgs(StatusList list)
        {
            ItemList = list;
        }
    }

    public sealed class ItemListSelectedEventArgs : ItemListEventArgs
    {
        /// <summary>
        ///     The index of the item that was selected.
        /// </summary>
        public int ItemIndex;

        public ItemListSelectedEventArgs(int itemIndex, StatusList list) : base(list)
        {
            ItemIndex = itemIndex;
        }
    }

    public sealed class ItemListDeselectedEventArgs : ItemListEventArgs
    {
        /// <summary>
        ///     The index of the item that was selected.
        /// </summary>
        public int ItemIndex;

        public ItemListDeselectedEventArgs(int itemIndex, StatusList list) : base(list)
        {
            ItemIndex = itemIndex;
        }
    }

    public sealed class ItemListHoverEventArgs : ItemListEventArgs
    {
        /// <summary>
        ///     The index of the item that was selected.
        /// </summary>
        public int ItemIndex;

        public ItemListHoverEventArgs(int itemIndex, StatusList list) : base(list)
        {
            ItemIndex = itemIndex;
        }
    }

    public enum ItemListSelectMode : byte
    {
        None,
        Single,
        Multiple,
        Button,
    }

    public sealed class StatusItem
    {
        public event Action<StatusItem>? OnSelected;
        public event Action<StatusItem>? OnDeselected;

        private bool _selected = false;
        private bool _disabled = false;

        public StatusList Owner { get; }
        public string? Text { get; set; }
        public string? TooltipText { get; set; }
        public Texture? Icon { get; set; }
        public UIBox2 IconRegion { get; set; }
        public Color IconModulate { get; set; } = Color.White;
        public bool Selectable { get; set; } = true;
        public bool TooltipEnabled { get; set; } = true;
        public UIBox2? Region { get; set; }
        public object? Metadata { get; set; }

        public bool Disabled
        {
            get => _disabled;
            set
            {
                _disabled = value;
                if (Selected)
                    Selected = false;
            }
        }

        public bool Selected
        {
            get => _selected;
            set
            {
                if (!Selectable)
                    return;
                _selected = value;
                if (_selected)
                    OnSelected?.Invoke(this);
                else
                    OnDeselected?.Invoke(this);
            }
        }

        public Vector2 IconSize
        {
            get
            {
                if (Icon == null)
                    return Vector2.Zero;
                return IconRegion.Size != Vector2.Zero ? IconRegion.Size : Icon.Size;
            }
        }

        public StatusItem(StatusList owner)
        {
            Owner = owner;
        }
    }
}
